#!/usr/bin/env python

import argparse
from qsub import *
import sys

# arguments
parser = argparse.ArgumentParser()
parser.add_argument('-i_sfs', '--insertion_sfs',
                    help='The sfs file for insertions generated by indelSFS.py',
                    required=True)
parser.add_argument('-d_sfs', '--deletion_sfs',
                    help='The sfs file for deletions generated by indelSFS.py',
                    required=True)
parser.add_argument('-s_sfs', '--snp_sfs',
                    help='The sfs file for SNPs generated by snpSFS.py',
                    required=True)
parser.add_argument('-neutral_type', '--neutral_type',
                    help='ID of neutral snps in snp sfs file, eg intergenic_ww_ss (default)',
                    default='intergenic_ww_ss')
parser.add_argument('-n', '--n', help='Sample size', required=True)
parser.add_argument('-r', '--region', help='Genomic region of INDELs', required=True,
                    choices=['CDS', 'CDS_non_frameshift', 'CDS_frameshift', 'intron', 'intergenic', 'no_bins'])
parser.add_argument('-r2', '--region2', help='Optional second region of INDELs to compare between spectra',
                    choices=['CDS', 'CDS_non_frameshift', 'CDS_frameshift', 'intron', 'intergenic', 'no_bins'],
                    default='none')
parser.add_argument('-lrt', '--likelihood_ratio_test', help='Paramter to fix for likelihood ratio test',
                    choices=['gamma_indel', 'gamma_ins', 'gamma_del', 'kappa', 'equal_gammas_ins', 'equal_gammas_del',
                             'equal_kappas'], required=True)
parser.add_argument('-out', '--output_prefix',
                    help='Output path and file prefix for control, data and results files',
                    required=True)
parser.add_argument('-evolgen', '--evolgen', help='If specified will submit to lab queue', action='store_true',
                    default=False)
parser.add_argument('-node', '--node', help='Will run on specified nodes', default=0, type=int)
args = parser.parse_args()

# input checks
if args.region2 != 'none' and not args.likelihood_ratio_test.startswith('equal'):
    sys.exit('if -region2 specified, -lrt must be one of equal_gammas_ins ,equal_gammas_del, equal_kappas')


# functions
def read_sfs(sfs_file):
    sfs_dict = {}
    for line in open(sfs_file):
        if not line.startswith('F'):
            line = line.split('\t')
            if line[2] not in sfs_dict.keys():
                sfs_dict[line[2]] = [line[1]]
            else:
                sfs_dict[line[2]].append(line[1])
    return sfs_dict

# variables
i_sfs = read_sfs(args.insertion_sfs)
d_sfs = read_sfs(args.deletion_sfs)
s_sfs = read_sfs(args.snp_sfs)
region = args.region
region2 = args.region2
n = args.n
lrt = args.likelihood_ratio_test
out_prefix = args.output_prefix
node = args.node

neutral_snp_sfs = s_sfs[args.neutral_type]

# algorithm_list = [('NLOPT_LN_NELDERMEAD', '500'), ('NLOPT_LD_SLSQP', '50'), ('NLOPT_LD_LBFGS', '50')]
algorithm_list = [('NLOPT_LN_NELDERMEAD', '500'), ('NLOPT_LD_SLSQP', '50')]

# constraints
constraints = 'none'
if lrt.startswith('equal'):
    constraints = lrt
    lrt = 'constraint'

constraint_options = {'equal_gammas_ins': '{4, 10}',
                      'equal_gammas_del': '{5, 11}',
                      'equal_kappas': '{3, 9}',
                      'none': ''}

# reductions
reduction_options = {'kappa': ['reduced_kappa', 'reduced: {true, 1, 1}\n', '1', ''],
                     'gamma_indel': ['reduced_gamma', 'reduced: {true, 2, 3, 0}\n', '2', ''],
                     'gamma_ins': ['reduced_gamma_ins', 'reduced: {true, 2, 0}\n', '1', ''],
                     'gamma_del': ['reduced_gamma_del', 'reduced: {true, 3, 0}\n', '1', ''],
                     'constraint': ['constraint', 'full\n', '1', constraint_options[constraints]],
                     'none': ['full', 'full\n', '', '']}

out_put_locations = {z: {'none': '', lrt: ''} for z in [y[0] for y in algorithm_list]}

jids = []
# write data file
for x in ['none', lrt]:
    reduction = reduction_options[x]
    data_file = out_prefix + '.' + reduction[0] + '.data'
    constraint = reduction[3]

    data_contents = ('begin[common]\n'
                     'n: ' + n + '\n'
                     'with_r: true\n'
                     'end[common]\n'
                     '\n'
                     'begin[data]\n'
                     '\n'
                     '[snp]\n'
                     'm: 1\n'
                     'sfs: ' + ', '.join(neutral_snp_sfs) + '\n'
                     'reduced: {1, 0}\n'
                     '\n'
                     '[indel]\n'
                     'insertion\n'
                     'm: 1\n'
                     'sfs: ' + ', '.join(i_sfs[region]) + '\n'
                     'deletion\n'
                     'm: 1\n'
                     'sfs: ' + ', '.join(d_sfs[region]) + '\n' +
                     reduction[1] +
                     '\n')

    if region2 is not 'none':
        data_contents += ('[indel]\n'
                          'insertion\n'
                          'm: 1\n'
                          'sfs: ' + ', '.join(i_sfs[region2]) + '\n'
                          'deletion\n'
                          'm: 1\n'
                          'sfs: ' + ', '.join(d_sfs[region2]) + '\n' +
                          reduction[1] +
                          '\n')

    data_contents += ('end[data]\n'
                      '\n'
                      'begin[constraints]\n' +
                      constraint + '\n'
                      'end[constraints]')

    with open(data_file, 'w') as data_out:
        data_out.write(data_contents)

    # write control file
    for alg in algorithm_list:

        algorithm = alg[0]
        num_searches = alg[1]

        control_file = out_prefix + '.' + reduction[0] + '.' + algorithm.lower() + '.control'
        result_file = out_prefix + '.' + reduction[0] + '.' + algorithm.lower() + '.results'
        log_file = out_prefix + '.' + reduction[0] + '.' + algorithm.lower() + '.log'
        jid = out_prefix[out_prefix.rfind('/')+1:] + '.' + reduction[0] + '.' + algorithm.lower() + '.sh'
        jids.append(jid)

        out_put_locations[algorithm][x] = result_file

        control_contents = ('data_file: ' + data_file + '\n'
                            'theta_range: 1, 1000000\n'
                            'kappa_range: 0.01, 100\n'
                            'gamma_range: -1000, 500\n'
                            'e_range: 0, 0.3\n'
                            'r_range: 0.02, 50\n'
                            'algorithm: ' + algorithm + '\n'
                            'init_method: 1\n'
                            'rftol: 1e-10\n'
                            'maxeval: 100000\n'
                            'maxtime: 600\n'
                            'num_searches: ' + num_searches + '\n'
                            'imprftol: 1e-10\n'
                            'nnoimp: 3\n'
                            'maximp: 50')

        with open(control_file, 'w') as control_out:
            control_out.write(control_contents)

        # submit anavar jobs per algorithm
        anavar_cmd = 'anavar ' + control_file + ' ' + result_file + ' ' + log_file
        q_sub([anavar_cmd], out_prefix + '.' + reduction[0] + '.' + algorithm.lower(),
              evolgen=args.evolgen, node=node, t=48, jid=jid)

# construct merged ml output
ml_out = out_prefix + '.maxL.txt'
with open(ml_out, 'w') as mlo:
    mlo.write('model\talgorithm\tsnp_theta\tsnp_error\tsnp_gamma\t'
              'indel_theta\tindel_kappa\tinsertion_gamma\tdeletion_gamma\tinsertion_error\tdeletion_error\t'
              'indel_theta2\tindel_kappa2\tinsertion_gamma2\tdeletion_gamma2\tinsertion_error2\tdeletion_error2'
              '\tlnL\tp_value\n')

# submit jobs for processing output
cmd_list = []
df = reduction_options[lrt][2]
for a in out_put_locations.keys():
    locs = out_put_locations[a]
    cmd_list.append('./process_model_data.py '
                    '-data1 ' + locs['none'] + ' '
                    '-data2 ' + locs[lrt] + ' '
                    '-df ' + df + ' >> ' + ml_out)

q_sub(cmd_list, out_prefix + '.ml_best.ratiotest', hold=jids, evolgen=args.evolgen, node=node)
